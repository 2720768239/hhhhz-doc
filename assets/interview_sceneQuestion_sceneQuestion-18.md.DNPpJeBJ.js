import{_ as e,c as i,o,a4 as a}from"./chunks/framework.ChnUdrHZ.js";const p=JSON.parse('{"title":"Window 对象上频繁绑定内容，有什么风险","description":"","frontmatter":{},"headers":[],"relativePath":"interview/sceneQuestion/sceneQuestion-18.md","filePath":"interview/sceneQuestion/sceneQuestion-18.md","lastUpdated":1726816352000}'),n={name:"interview/sceneQuestion/sceneQuestion-18.md"},t=a('<h1 id="window-对象上频繁绑定内容-有什么风险" tabindex="-1">Window 对象上频繁绑定内容，有什么风险 <a class="header-anchor" href="#window-对象上频繁绑定内容-有什么风险" aria-label="Permalink to &quot;Window 对象上频繁绑定内容，有什么风险&quot;">​</a></h1><p>微前端，快照沙箱</p><h2 id="风险分析" tabindex="-1">风险分析 <a class="header-anchor" href="#风险分析" aria-label="Permalink to &quot;风险分析&quot;">​</a></h2><ol><li>命名冲突，window.hello = &#39;world&#39;，人人都命名 hello，导致覆盖</li><li>全局污染，被人修改，window.a = 1，window.a = 2，导致数据污染</li><li>安全风险。挂在 window.hello，任何人都能从这获取</li><li>性能问题，增加内存开销。很多人都是只管绑定，不管解绑</li></ol><h2 id="解决方案" tabindex="-1">解决方案 <a class="header-anchor" href="#解决方案" aria-label="Permalink to &quot;解决方案&quot;">​</a></h2><ol><li>模块化，把 window 上的内容封装到模块中，通过模块来访问</li><li>命名空间，把 window 上的内容封装到命名空间中，通过命名空间来访问</li><li>IIFE（形成闭包，形成独立作用域）</li><li>开启严格模式</li><li>快照沙箱，把 window 上的内容保存下来，当需要的时候再恢复，恢复的时候再保存，保证 window 上的内容不变</li></ol>',6),l=[t];function s(d,r,c,w,_,h){return o(),i("div",null,l)}const m=e(n,[["render",s]]);export{p as __pageData,m as default};
